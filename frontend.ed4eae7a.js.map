{"mappings":"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","sources":["<anon>","src/index.ts"],"sourcesContent":["var $8a4d19d4fe4fde45$exports = {};\n/*\nAs it is right now `index.ts` is dedicated to one thing only:\n\n    Changing the navbar color based on which section the user is looking at.\n\nAre there no CSS-only solutions?\n\n    One viable CSS-only solution could be to add `backdrop-filter: blur(64px);`\n    to the navbar. It creates a sort of \"frosted glass\" effect as the navbar\n    is on top of the different sections. There are three downsides:\n    1) The forsted glass effect can be a little annoying. For instance, the\n       navbar turns white-ish when positioned over one of the white stripes.\n    2) With the current layout, where the navbar is neither\n      `position: absolute` nor `position: sticky`, the navbar is actually never\n       overlapping with the sections.\n    3) Quick testing on Firefox revealed that `backdrop-filter` didn't play nice\n       with our implementation of the mobile dropdown menue (implemented using\n       `transform: translateY(..)` and `transform: translateZ(..)`)\n    Downside (1) is the only downside where I cannot see a solution. Downside\n    (2) and (3) simply mean that the implementation might be a litte complex\n    (like the JS solution below)\n\nHow does this work?\n\n    We keep track of which sections are visible in the `sectionVisibillity`\n    variable (more on HOW we keep track of that later), and simply assume\n    that if section-1 is visible, the navbar should have it's background color.\n    If section-1 is not visible, but section-2 is, then is should have section-2\n    background color, etc.\n\n    There are edge-cases that are not handled: What if no section appear to be\n    visible? What if section-1 and section-3 are visible, but not section-3??\n\n    We keep track of which sections are visible using an `IntersectionObserver`\n    which is an interface designed for keeping track of just these things in\n    a very performant manner.\n */ function $8a4d19d4fe4fde45$var$main() {\n    /*\n    Get all the relevant elements from the DOM\n  */ const mainTag = (()=>{\n        const elem = document.getElementsByTagName(\"main\");\n        if (elem.length > 1) throw new Error(\"Expected one <main> tag only\");\n        if (elem.length === 0) throw new Error(\"Expected there to be a <main> tag\");\n        return elem[0];\n    })();\n    const navBar = (()=>{\n        const elem = document.getElementsByTagName(\"nav\");\n        if (elem.length > 1) throw new Error(\"Expected one <nav> tag only\");\n        if (elem.length === 0) throw new Error(\"Expected there to be a <nav> tag\");\n        return elem[0];\n    })();\n    const section1 = (()=>{\n        const elem = document.getElementById(\"section-1\");\n        if (elem instanceof HTMLElement) return elem;\n        throw new Error(\"Expected there to be a #section-1 tag\");\n    })();\n    const section2 = (()=>{\n        const elem = document.getElementById(\"section-2\");\n        if (elem instanceof HTMLElement) return elem;\n        throw new Error(\"Expected there to be a #section-2 tag\");\n    })();\n    const section3 = (()=>{\n        const elem = document.getElementById(\"section-3\");\n        if (elem instanceof HTMLElement) return elem;\n        throw new Error(\"Expected there to be a #section-3 tag\");\n    })();\n    const section4 = (()=>{\n        const elem = document.getElementById(\"section-4\");\n        if (elem instanceof HTMLElement) return elem;\n        throw new Error(\"Expected there to be a #section-4 tag\");\n    })();\n    const section5 = (()=>{\n        const elem = document.getElementById(\"section-5\");\n        if (elem instanceof HTMLElement) return elem;\n        throw new Error(\"Expected there to be a #section-5 tag\");\n    })();\n    // const section6: HTMLElement = (() => {\n    //   const elem = document.getElementById(\"section-6\")\n    //   if (elem instanceof HTMLElement) {\n    //     return elem\n    //   }\n    //   throw new Error(\"Expected there to be a #section-6 tag\")\n    // })()\n    // const section7: HTMLElement = (() => {\n    //   const elem = document.getElementById(\"section-7\")\n    //   if (elem instanceof HTMLElement) {\n    //     return elem\n    //   }\n    //   throw new Error(\"Expected there to be a #section-7 tag\")\n    // })()\n    // const section8: HTMLElement = (() => {\n    //   const elem = document.getElementById(\"section-8\")\n    //   if (elem instanceof HTMLElement) {\n    //     return elem\n    //   }\n    //   throw new Error(\"Expected there to be a #section-8 tag\")\n    // })()\n    // Keep track of which section are visible.\n    const sectionVisibillity = $8a4d19d4fe4fde45$var$initialVisibillity();\n    // Look at `sectionVisibillity` and update navbar bg color accordingly.\n    function updateNavbarColor() {\n        if (sectionVisibillity[\"section-1\"] === true) {\n            navBar.style.backgroundColor = \"var(--green)\";\n            return;\n        }\n        if (sectionVisibillity[\"section-2\"] === true) {\n            navBar.style.backgroundColor = \"var(--blue)\";\n            return;\n        }\n        if (sectionVisibillity[\"section-3\"] === true) {\n            navBar.style.backgroundColor = \"var(--green)\";\n            return;\n        }\n        if (sectionVisibillity[\"section-4\"] === true) {\n            navBar.style.backgroundColor = \"var(--blue)\";\n            return;\n        }\n        if (sectionVisibillity[\"section-5\"] === true) {\n            navBar.style.backgroundColor = \"var(--gray)\";\n            return;\n        }\n        // if (sectionVisibillity[\"section-6\"] === true) {\n        //   navBar.style.backgroundColor = \"var(--red)\"\n        //   return\n        // }\n        // if (sectionVisibillity[\"section-7\"] === true) {\n        //   navBar.style.backgroundColor = \"var(--green)\"\n        //   return\n        // }\n        // if (sectionVisibillity[\"section-8\"] === true) {\n        //   navBar.style.backgroundColor = \"var(--blue)\"\n        //   return\n        // }\n        throw new Error(\"Expected at least on section to be visible\");\n    }\n    // Keep track of which section are visible\n    const sectionIntersectionObserver = new IntersectionObserver((events)=>{\n        for (const event of events){\n            if (![\n                \"section-1\",\n                \"section-2\",\n                \"section-3\",\n                \"section-4\",\n                \"section-5\"\n            ].includes(event.target.id)) throw new Error(`Unexpected id in intersection observer callback: \"${event.target.id}\"`);\n            sectionVisibillity[event.target.id] = event.isIntersecting;\n        }\n        updateNavbarColor();\n    }, {\n        // Why these options: When programatically scrolling to a section it can be\n        // the case that while a section is totaly not vissible to a user, it is\n        // still technically in the viewport as far as the intersection observer is\n        // concearned. By setting rootMargin: \"-1px\" we basically tell the\n        // interesction observer that a section needs to be at least one full pixel\n        // in the viewport to count as vissible.\n        root: mainTag,\n        rootMargin: \"-1px\"\n    });\n    sectionIntersectionObserver.observe(section1);\n    sectionIntersectionObserver.observe(section2);\n    sectionIntersectionObserver.observe(section3);\n    sectionIntersectionObserver.observe(section4);\n    sectionIntersectionObserver.observe(section5);\n    // sectionIntersectionObserver.observe(section6)\n    // sectionIntersectionObserver.observe(section7)\n    // sectionIntersectionObserver.observe(section8)\n    /*\n  Why is this here??\n\n  It's a little complicated, but basically, when loading the page for the first\n  time we want the color of the navbar to update to the right color ASAP,\n\n  after that, when scrolling, we might want a subtle transition. If we add the\n  transition in the CSS from the beginning then it will apply to the above case\n  when we want to change color ASAP. So we set the style hare instead, AFTER\n  the navbar has gotten its initial color.\n  */ setTimeout(()=>{\n        navBar.style.transition = \"background-color 0.3s\";\n    }, 1000);\n}\nfunction $8a4d19d4fe4fde45$var$initialVisibillity() {\n    return {\n        \"section-1\": true,\n        \"section-2\": false,\n        \"section-3\": false,\n        \"section-4\": false,\n        \"section-5\": false\n    };\n}\nif (document.readyState === \"complete\") $8a4d19d4fe4fde45$var$main();\nelse document.addEventListener(\"DOMContentLoaded\", $8a4d19d4fe4fde45$var$main);\n\n\n//# sourceMappingURL=frontend.ed4eae7a.js.map\n","/*\nAs it is right now `index.ts` is dedicated to one thing only:\n\n    Changing the navbar color based on which section the user is looking at.\n\nAre there no CSS-only solutions?\n\n    One viable CSS-only solution could be to add `backdrop-filter: blur(64px);`\n    to the navbar. It creates a sort of \"frosted glass\" effect as the navbar\n    is on top of the different sections. There are three downsides:\n    1) The forsted glass effect can be a little annoying. For instance, the\n       navbar turns white-ish when positioned over one of the white stripes.\n    2) With the current layout, where the navbar is neither\n      `position: absolute` nor `position: sticky`, the navbar is actually never\n       overlapping with the sections.\n    3) Quick testing on Firefox revealed that `backdrop-filter` didn't play nice\n       with our implementation of the mobile dropdown menue (implemented using\n       `transform: translateY(..)` and `transform: translateZ(..)`)\n    Downside (1) is the only downside where I cannot see a solution. Downside\n    (2) and (3) simply mean that the implementation might be a litte complex\n    (like the JS solution below)\n\nHow does this work?\n\n    We keep track of which sections are visible in the `sectionVisibillity`\n    variable (more on HOW we keep track of that later), and simply assume\n    that if section-1 is visible, the navbar should have it's background color.\n    If section-1 is not visible, but section-2 is, then is should have section-2\n    background color, etc.\n\n    There are edge-cases that are not handled: What if no section appear to be\n    visible? What if section-1 and section-3 are visible, but not section-3??\n\n    We keep track of which sections are visible using an `IntersectionObserver`\n    which is an interface designed for keeping track of just these things in\n    a very performant manner.\n */\n\nfunction main() {\n\n  /*\n    Get all the relevant elements from the DOM\n  */\n\n  const mainTag: HTMLElement = (() => {\n    const elem = document.getElementsByTagName(\"main\")\n    if (elem.length > 1) {\n      throw new Error(\"Expected one <main> tag only\")\n    }\n    if (elem.length === 0) {\n      throw new Error(\"Expected there to be a <main> tag\")\n    }\n\n    return elem[0];\n  })()\n\n  const navBar: HTMLElement = (() => {\n    const elem = document.getElementsByTagName(\"nav\")\n    if (elem.length > 1) {\n      throw new Error(\"Expected one <nav> tag only\")\n    }\n    if (elem.length === 0) {\n      throw new Error(\"Expected there to be a <nav> tag\")\n    }\n\n    return elem[0];\n  })()\n\n  const section1: HTMLElement = (() => {\n    const elem = document.getElementById(\"section-1\")\n    if (elem instanceof HTMLElement) {\n      return elem\n    }\n\n    throw new Error(\"Expected there to be a #section-1 tag\")\n  })()\n\n  const section2: HTMLElement = (() => {\n    const elem = document.getElementById(\"section-2\")\n    if (elem instanceof HTMLElement) {\n      return elem\n    }\n\n    throw new Error(\"Expected there to be a #section-2 tag\")\n  })()\n\n  const section3: HTMLElement = (() => {\n    const elem = document.getElementById(\"section-3\")\n    if (elem instanceof HTMLElement) {\n      return elem\n    }\n\n    throw new Error(\"Expected there to be a #section-3 tag\")\n  })()\n\n  const section4: HTMLElement = (() => {\n    const elem = document.getElementById(\"section-4\")\n    if (elem instanceof HTMLElement) {\n      return elem\n    }\n\n    throw new Error(\"Expected there to be a #section-4 tag\")\n  })()\n\n  const section5: HTMLElement = (() => {\n    const elem = document.getElementById(\"section-5\")\n    if (elem instanceof HTMLElement) {\n      return elem\n    }\n\n    throw new Error(\"Expected there to be a #section-5 tag\")\n  })()\n\n  // const section6: HTMLElement = (() => {\n  //   const elem = document.getElementById(\"section-6\")\n  //   if (elem instanceof HTMLElement) {\n  //     return elem\n  //   }\n\n  //   throw new Error(\"Expected there to be a #section-6 tag\")\n  // })()\n\n  // const section7: HTMLElement = (() => {\n  //   const elem = document.getElementById(\"section-7\")\n  //   if (elem instanceof HTMLElement) {\n  //     return elem\n  //   }\n\n  //   throw new Error(\"Expected there to be a #section-7 tag\")\n  // })()\n\n  // const section8: HTMLElement = (() => {\n  //   const elem = document.getElementById(\"section-8\")\n  //   if (elem instanceof HTMLElement) {\n  //     return elem\n  //   }\n\n  //   throw new Error(\"Expected there to be a #section-8 tag\")\n  // })()\n\n  // Keep track of which section are visible.\n  const sectionVisibillity: Visibility = initialVisibillity()\n\n  // Look at `sectionVisibillity` and update navbar bg color accordingly.\n  function updateNavbarColor() {\n    if (sectionVisibillity[\"section-1\"] === true) {\n      navBar.style.backgroundColor = \"var(--green)\"\n      return\n    }\n    if (sectionVisibillity[\"section-2\"] === true) {\n      navBar.style.backgroundColor = \"var(--blue)\"\n      return\n    }\n    if (sectionVisibillity[\"section-3\"] === true) {\n      navBar.style.backgroundColor = \"var(--green)\"\n      return\n    }\n    if (sectionVisibillity[\"section-4\"] === true) {\n      navBar.style.backgroundColor = \"var(--blue)\"\n      return\n    }\n    if (sectionVisibillity[\"section-5\"] === true) {\n      navBar.style.backgroundColor = \"var(--gray)\"\n      return\n    }\n    // if (sectionVisibillity[\"section-6\"] === true) {\n    //   navBar.style.backgroundColor = \"var(--red)\"\n    //   return\n    // }\n    // if (sectionVisibillity[\"section-7\"] === true) {\n    //   navBar.style.backgroundColor = \"var(--green)\"\n    //   return\n    // }\n    // if (sectionVisibillity[\"section-8\"] === true) {\n    //   navBar.style.backgroundColor = \"var(--blue)\"\n    //   return\n    // }\n\n    throw new Error(\"Expected at least on section to be visible\")\n  }\n\n  // Keep track of which section are visible\n  const sectionIntersectionObserver = new IntersectionObserver(events => {\n    for (const event of events) {\n      if (![\n        \"section-1\",\n        \"section-2\",\n        \"section-3\",\n        \"section-4\",\n        \"section-5\",\n        // \"section-6\",\n        // \"section-7\",\n        // \"section-8\"\n      ].includes(event.target.id)) {\n        throw new Error(\n          `Unexpected id in intersection observer callback: \"${event.target.id}\"`)\n      }\n\n      sectionVisibillity[event.target.id] = event.isIntersecting\n    }\n\n    updateNavbarColor()\n  }, {\n    // Why these options: When programatically scrolling to a section it can be\n    // the case that while a section is totaly not vissible to a user, it is\n    // still technically in the viewport as far as the intersection observer is\n    // concearned. By setting rootMargin: \"-1px\" we basically tell the\n    // interesction observer that a section needs to be at least one full pixel\n    // in the viewport to count as vissible.\n    root: mainTag,\n    rootMargin: \"-1px\"\n  })\n\n  sectionIntersectionObserver.observe(section1)\n  sectionIntersectionObserver.observe(section2)\n  sectionIntersectionObserver.observe(section3)\n  sectionIntersectionObserver.observe(section4)\n  sectionIntersectionObserver.observe(section5)\n  // sectionIntersectionObserver.observe(section6)\n  // sectionIntersectionObserver.observe(section7)\n  // sectionIntersectionObserver.observe(section8)\n\n  /*\n  Why is this here??\n\n  It's a little complicated, but basically, when loading the page for the first\n  time we want the color of the navbar to update to the right color ASAP,\n\n  after that, when scrolling, we might want a subtle transition. If we add the\n  transition in the CSS from the beginning then it will apply to the above case\n  when we want to change color ASAP. So we set the style hare instead, AFTER\n  the navbar has gotten its initial color.\n  */\n  setTimeout(() => { navBar.style.transition = \"background-color 0.3s\" }, 1000)\n}\n\ntype Visibility = {\n  \"section-1\": boolean,\n  \"section-2\": boolean,\n  \"section-3\": boolean,\n  \"section-4\": boolean,\n  \"section-5\": boolean,\n  // \"section-6\": boolean,\n  // \"section-7\": boolean,\n  // \"section-8\": boolean,\n}\n\nfunction initialVisibillity(): Visibility {\n  return {\n    \"section-1\": true,\n    \"section-2\": false,\n    \"section-3\": false,\n    \"section-4\": false,\n    \"section-5\": false,\n    // \"section-6\": false,\n    // \"section-7\": false,\n    // \"section-8\": false,\n  }\n}\n\nif (document.readyState === \"complete\") {\n  main()\n} else {\n  document.addEventListener(\"DOMContentLoaded\", main)\n}\n"],"names":["$8a4d19d4fe4fde45$var$main","mainTag","elem","document","getElementsByTagName","length","Error","navBar","section1","getElementById","HTMLElement","section2","section3","section4","section5","sectionVisibillity","sectionIntersectionObserver","IntersectionObserver","events","event","includes","target","id","isIntersecting","updateNavbarColor","style","backgroundColor","root","rootMargin","observe","setTimeout","transition","readyState","addEventListener"],"version":3,"file":"frontend.ed4eae7a.js.map"}